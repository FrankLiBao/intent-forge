# 意图驱动开发 (Intent-Driven Development)

## 权力颠倒

几十年来,代码一直是王道。规范为代码服务——它们是可有可无的文档,一旦"真正的工作"开始就被丢弃。我们认可代码是软件开发的最终产物,因此在开发过程中,我们尽可能快地到达代码阶段。规范、设计文档、架构决策记录——所有这些都只是临时的脚手架。

意图驱动开发颠覆了这种关系。规范不再仅仅*指导*实现,它们*生成*实现。编写良好的规范,配合现代AI模型,可以直接产生功能完整、经过测试且符合架构的代码。代码成为规范的产物,而不是相反。

这不是增量式的改进——这是范式的转变。

## 为什么意图驱动开发现在很重要

三大趋势使意图驱动开发成为可能:

### 趋势 1: AI 擅长规范解释

现代大语言模型(LLM)在两个关键能力上表现出色:

1. **将自然语言需求转化为结构化规范** - AI可以从用户故事、功能描述和业务需求中提取清晰、可操作的规范。
2. **从规范生成可工作的实现** - 给定良好的规范,AI可以生成符合架构原则、最佳实践和测试标准的代码。

这些能力使规范从*文档*转变为*可执行工件*。

### 趋势 2: 现代应用是声明式的

现代软件栈越来越声明式:

- **基础设施**: Terraform、Kubernetes、Docker Compose
- **前端**: React(JSX)、SwiftUI、Jetpack Compose
- **后端**: GraphQL schemas、OpenAPI/Swagger、gRPC proto files
- **数据库**: Prisma schemas、SQL migrations、MongoDB schemas

声明式系统非常适合意图驱动开发,因为它们已经是*规范优先*的。规范不仅描述系统应该做什么,它们*就是*系统本身。

### 趋势 3: 技术栈变化加速

技术栈的变化速度前所未有:

- 每年都有新的前端框架
- 云服务不断推出新功能
- 语言版本快速演进
- 最佳实践持续更新

在这种环境下,过早锁定技术细节会造成技术债务。意图驱动开发允许您在高层次定义*做什么*,然后根据当前最佳实践生成实现。想切换框架?重新生成。想采用新模式?更新规范并重新实现。

## 核心原则

### 1. 规范是一等公民

在意图驱动开发中,规范不是次要文档——它们是主要工件:

- **受版本控制** - 规范与代码一起存储在git中
- **经过审查** - Pull requests审查规范,而不仅仅是代码
- **可测试** - 规范包含验收标准,作为测试的基础
- **可演化** - 规范随需求变化而更新,代码随之重新生成

### 2. 分离意图和实现

意图驱动开发严格分离*做什么*(意图)和*如何做*(实现):

**意图层**:
- 用户故事和使用场景
- 功能需求
- 验收标准
- 非功能性需求(性能、安全性、可访问性)

**实现层**:
- 技术栈选择
- 架构模式
- 库和框架
- 部署策略

这种分离允许您在不更改意图的情况下更改实现,反之亦然。

### 3. 渐进式细化

意图驱动开发不是一次性生成——它是多阶段细化:

1. **宪法阶段** - 建立项目级原则和约束
2. **规范阶段** - 定义功能需求和用户故事
3. **澄清阶段** - 解决歧义和未指定区域
4. **计划阶段** - 设计技术实施方法
5. **任务阶段** - 将计划分解为可执行任务
6. **实施阶段** - 生成代码并执行任务
7. **分析阶段** - 验证一致性和完整性

每个阶段都建立在前一个阶段之上,随着我们向实现前进,细节逐步增加。

### 4. 约束通过模板实现质量

自由格式的提示导致不一致的输出。意图驱动开发使用*结构化模板*来约束AI输出:

**规范模板**包含:
- 用户故事部分(必需)
- 功能需求(必需)
- 非功能性需求(可选)
- 技术约束(可选)
- 验收检查清单(必需)

**计划模板**强制执行:
- Phase -1: 宪法合规性门控
- Phase 0: 研究和技术可行性
- Phase 1: 设计、合约和数据模型
- 核心实施步骤
- 验证和测试策略

模板充当护栏,确保AI生成全面、一致、可执行的工件。

### 5. 宪法作为架构权威

每个项目都以一部**宪法**开始——一套不可协商的原则,指导所有开发决策:

示例原则:
- **库优先原则** - 优先使用库而不是手写实现
- **CLI接口强制** - 所有功能必须可从CLI访问
- **测试优先要求** - 在实现之前编写测试
- **简洁性原则** - 优先选择简单解决方案而不是复杂解决方案

宪法在分析阶段自动强制执行。违反宪法的规范或计划会被标记为关键问题,必须在实施前解决。

## 意图驱动开发工作流

### 完整工作流程

```
用户需求
    ↓
【阶段 0: 宪法】
/intent.constitution → constitution.md
    ↓
【阶段 1: 规范】
/intent.specify → spec.md
    ↓
【阶段 2: 澄清】(可选但推荐)
/intent.clarify → 更新 spec.md
    ↓
【阶段 3: 计划】
/intent.plan → plan.md, research.md, data-model.md, contracts/
    ↓
【阶段 4: 任务】
/intent.tasks → tasks.md
    ↓
【阶段 5: 分析】(可选但推荐)
/intent.analyze → 分析报告
    ↓
【阶段 6: 实施】
/intent.implement → 工作代码
    ↓
完成的功能
```

### 阶段说明

#### 阶段 0: 宪法

**输入**: 项目原则、架构约束、质量标准
**输出**: `constitution.md`
**目的**: 建立不可协商的规则,指导所有后续决策

示例宪法条款:
```markdown
## 条款 I: 库优先原则

在每个集成点,我们优先使用成熟的库而不是自定义实现。

理由: 减少维护负担,提高可靠性,加快开发速度
```

#### 阶段 1: 规范

**输入**: 功能描述、用户故事、业务需求
**输出**: `spec.md`
**目的**: 定义*做什么*,而不是*如何做*

规范包含:
- 按优先级排序的用户故事
- 每个故事的验收场景
- 非功能性需求
- 范围外明确排除的内容

#### 阶段 2: 澄清

**输入**: `spec.md` 中的歧义和未指定区域
**输出**: 更新的 `spec.md`
**目的**: 通过结构化问答解决不确定性

AI会:
1. 识别规范中的模糊区域
2. 生成针对性澄清问题(最多5个)
3. 将答案编码回规范

这减少了下游返工,因为实施前解决了歧义。

#### 阶段 3: 计划

**输入**: 技术栈选择、架构约束
**输出**: `plan.md`、`research.md`、`data-model.md`、`contracts/`
**目的**: 将意图转化为技术方法

计划包含:
- **Phase -1**: 宪法合规性检查
- **Phase 0**: 技术研究和可行性
- **Phase 1**: API合约、数据模型、快速入门
- **核心实施**: 按依赖顺序排列的实施步骤

#### 阶段 4: 任务

**输入**: `plan.md`
**输出**: `tasks.md`
**目的**: 将计划分解为可执行的、有依赖关系的任务

任务特征:
- 按用户故事组织
- 标记并行性 `[P]`
- 包含文件路径
- 测试优先排序

#### 阶段 5: 分析(可选)

**输入**: `spec.md`、`plan.md`、`tasks.md`、`constitution.md`
**输出**: 分析报告
**目的**: 在实施前验证一致性

分析检查:
- 规范和任务之间的覆盖差距
- 计划和规范之间的不一致
- 宪法违规
- 重复或冲突的需求

#### 阶段 6: 实施

**输入**: `tasks.md`
**输出**: 工作代码、测试、文档
**目的**: 执行计划

AI会:
1. 按依赖顺序读取任务
2. 生成代码、测试和文档
3. 运行验证检查
4. 报告进度和问题

## 最佳实践

### 1. 从小处开始

不要试图一次性规范整个应用程序。从单个功能开始:

**好**: "用户可以创建账户并使用电子邮件登录"
**不好**: "构建一个具有身份验证、授权、用户管理、通知和审计的完整平台"

### 2. 尽早澄清

在创建计划之前运行 `/intent.clarify`。在规范阶段解决歧义比在实施过程中解决便宜得多。

### 3. 将测试作为验收标准

将验收场景写成可测试的假设:

```markdown
**假设** 用户有空购物车
**当** 他们添加一个产品
**那么** 购物车显示1个商品和正确的总价
```

这些直接转化为测试用例。

### 4. 使用宪法来强制执行架构

不要在每个规范中重复架构决策。将它们放在宪法中一次:

```markdown
## 条款 III: 测试优先要求

所有公共API端点必须在实施之前有集成测试。

强制执行: /intent.analyze 将标记缺少测试的任务
```

### 5. 分开意图和技术

在 `/intent.specify` 中:谈论*用户能做什么*
在 `/intent.plan` 中:谈论*如何实现它*

不要混淆这两者——这使得在不更改需求的情况下更改实现成为可能。

### 6. 审查规范,而不仅仅是代码

将规范审查作为pull request流程的一部分:
1. 审查规范的完整性和清晰度
2. 审查计划的技术方法
3. 审查任务的可执行性
4. 然后审查生成的代码

这捕获了传统代码审查遗漏的设计问题。

## 与传统开发的对比

| 方面 | 传统开发 | 意图驱动开发 |
|------|----------|--------------|
| **主要工件** | 代码 | 规范 |
| **规范角色** | 临时文档 | 可执行源码真相 |
| **AI用途** | 代码补全、调试 | 端到端实施 |
| **变更流程** | 修改代码 | 更新规范,重新生成 |
| **审查重点** | 代码质量 | 规范质量 |
| **技术锁定** | 早期且僵化 | 延迟且灵活 |

## 何时使用意图驱动开发

**非常适合**:
- 新功能开发(绿地)
- 探索性原型
- API优先项目
- 声明式基础设施
- 技术栈迁移

**不太适合**:
- 性能关键代码(需要手动优化)
- 复杂算法(需要人工设计)
- 遗留代码库现代化(首先需要提取规范)

## 结论

意图驱动开发代表了软件开发的基本转变——从代码优先到规范优先。通过使规范可执行,我们获得:

- **更快的开发** - AI处理样板和实施
- **更好的质量** - 模板和约束确保一致性
- **更高的灵活性** - 在不破坏规范的情况下更改技术
- **更清晰的沟通** - 规范是团队成员之间的共同语言

这不是用AI替代开发人员——这是用AI增强开发人员专注于重要事项:*定义应该构建什么*,而不是*如何构建它*。

---

**准备好开始了吗?** 查看 [README.md](./README.md) 获取安装说明和快速入门指南。
